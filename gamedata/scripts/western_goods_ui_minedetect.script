--- Original Author(s) : <unknown>
--- Edited : NLTP_ASHES
--- Date : 19/06/2023
--- License : Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)
---
--- Based off ui_dosimeter.script by <unknown>, script used to handle the UI for the Rangefinder.
---
--- UIMineDetector:Check function was written by GhenTuong.

-- ---------------------------------------------------------------------------------------------------------------------
-- Constants, global variables and imported functions
-- ---------------------------------------------------------------------------------------------------------------------

-- Constants
local CONST_UPDATE_FREQ_MIN      = 111                              -- in milliseconds
local CONST_UPDATE_FREQ_MAX      = 999                              -- in milliseconds
local CONST_DETECT_DIST_MIN_SQR  = 2500                             -- in pixels squared
local CONST_DETECT_DIST_MAX_SQR  = 40000                            -- in pixels squared
local CONST_MAX_RANGE_SQR        = 49                               -- in meters squared
local CONST_ITEM_SEC             = "wg_minedetect"                  -- name of the mine detector section

-- Imported functions
local dbg_printf             = western_goods_utils.dbg_printf

-- Singleton
GUI					         = nil                              -- instance, don't touch

-- ---------------------------------------------------------------------------------------------------------------------
-- General Functions
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to get the UI singleton for the UIRangefinder class.
--- @return UIRangefinder
function get_ui()
    if (not GUI) then
        GUI = UIMineDetector()
    end

    return GUI
end

-- ---------------------------------------------------------------------------------------------------------------------
-- Callbacks registration
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to register callbacks.
--- @return nil
function on_game_start()
end

-- ---------------------------------------------------------------------------------------------------------------------
-- UI Class
-- ---------------------------------------------------------------------------------------------------------------------

class "UIMineDetector" (CUIScriptWnd)

function UIMineDetector:__init() super()
    dbg_printf("[WG] UI MineDetector | Constructing GUI...")

    self:Show(true)
    self:Enable(true)

    -- Build UI
    self.xml = CScriptXmlInit()
    self.xml:ParseFile("ui_western_goods_minedetect.xml")
    self.xml:InitWindow("mine_detectror", 0, self)

    self.detect = self.xml:InitStatic("mine_detectror:detect", self)

    -- Sound effects
    self.detect_sfx = sound_object([[detectors\art_beep1]])

    -- Build variables
    self.update_timer = 0
    self.angle_min = -20
    self.angle_max = 20
    self.time_global = time_global()
end

function UIMineDetector:__finalize()
    GUI = nil
end

function UIMineDetector:Update()

    CUIScriptWnd.Update(self)

    -- Don't refresh if device isn't drawn out
    local active_det = db.actor:active_detector()
    if not active_det or active_det:section() ~= CONST_ITEM_SEC then
        return
    end

    -- Don't refresh if timer isn't hit
    self.time_global = time_global()
    if (self.time_global < self.update_timer) then
        return
    end

    -- Refresh device
    self:RefreshDevice(self:FindBest())
end

function UIMineDetector:RefreshDevice(best_aim, best_obj)

    -- If best mine is too far, no detection
    if (not best_aim or best_aim > CONST_DETECT_DIST_MAX_SQR) then
        self.update_timer = self.time_global + CONST_UPDATE_FREQ_MAX
        self.detect:Show(false)
        return
    end

    -- If best mine is really close, fast ticking
    if (best_aim < CONST_DETECT_DIST_MIN_SQR) then
        self.update_timer = self.time_global + CONST_UPDATE_FREQ_MIN
        self.detect:Show(not self.detect:IsShown())
        self.detect_sfx:play(db.actor, 0, sound_object.s2d)
        return
    end

    -- If best mine is somewhere in between
    local freq = normalize(best_aim, CONST_DETECT_DIST_MIN_SQR, CONST_DETECT_DIST_MAX_SQR) * CONST_UPDATE_FREQ_MAX
    freq = clamp(freq, CONST_UPDATE_FREQ_MIN, CONST_UPDATE_FREQ_MAX)

    self.update_timer = self.time_global + freq
    self.detect:Show(not self.detect:IsShown())
    self.detect_sfx:play(db.actor, 0, sound_object.s2d)
end

function UIMineDetector:FindBest()
    local mine_fields = self:GetMineFields()
    local mine_objs = self:GetMineObjects()

    local best_aim, best_mine = nil, nil

    local function try_best_mine(obj)
        local aim = self:CheckAim(obj)
        if self:IsValidMine(obj) and (not best_aim or aim < best_aim) then
            best_aim, best_mine = aim, obj
        end
    end

    for _, obj in pairs(mine_fields) do
        try_best_mine(obj)
    end

    for _, obj in pairs(mine_objs) do
        try_best_mine(obj)
    end

    return best_aim, best_mine
end

function UIMineDetector:CheckAim(mine)
    local w2ui = game.world2ui(mine:position())

    local center = vector():set(512, 384, 0)
    local aim = vector():set(w2ui.x, w2ui.y, 0)

    return center:distance_to_sqr(aim)
end

function UIMineDetector:IsValidMine(mine)
    local dist = db.actor:position():distance_to_sqr(mine:position())
    return dist <= CONST_MAX_RANGE_SQR
end

function UIMineDetector:GetMineFields()
    local mines = {}
    for _,obj in pairs(db.zone_by_name) do
        if (western_goods_utils.is_minefield(obj)) then
            mines[obj:id()] = obj
        end
    end
    return mines
end

function UIMineDetector:GetMineObjects()
    local mines = {}
    for id,_ in pairs(txr_mines._mines) do
        mines[id] = western_goods_utils.level_object_by_id(id)
    end
    return mines
end